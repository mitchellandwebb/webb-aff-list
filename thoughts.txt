


So I've structured the Yield monad to be very free, without committing to any data types. Just a 'yield' action in the context that can be adapted to any implementation. But to what degree can we do the same for the AffList? To what degree do we _want_ to do the same? Because in order to 'LiftAff', we need an actual implementation, unless we're doing Free monads ... which I don't want to do, since it isn't needed. But if we don't do this ... what _do_ we do? What does any action mean?

My brain ... isn't generating any ideas right now. Does it need to be like Flow, which was extensive and painful to write? Or can it work better? FUCK.

Well, the reason is that the monad has to be based on the operations of something that exists. And right now ... nothing exists. `Yield` was fine because Aff and StateT existed with their own known runtime executions. But we're trying to write AffList ... without any such runtime picture, or representation of a runtime. So we need a representation for it -- and it will have to be concrete, since no other Monad for what we're doing can exist. So what's needed for the AffList?

Well, we're working in a bizarre kind of context. In the general case, we know we have one or more communicating Programs. Each Program is in a Thread, and once the Thread is started, runs in a loop, writing results to a Port, and then repeats the loop; once the loop ends, the Thread code will notify a higher context that the Node is dead, which will notify nearby nodes that the next/previous item is dead. This will propagate -- the purpose is the stream, so nearby threads should _also_ die, since their results will now never be used. A typical Program in a Thread will essentially consist of a loop like 

```
whileNext prev \item -> do 
  value <- process item
  yield value
```

Is that actually true? Hmmm ... sort-of. We don't actually "take" from any previous item that is in context, but IF a previous item is injected, then we might run such a loop. However, in many cases, only a single value gets emitted, and a decision has to be made about what that single value means in terms of the output. OR an entire AffList is passed to a Program, -- only in that case would we instantiate it and process all its values. So in that case ... what actually _is_ a node, if all it sees in ordinary operation is an output port? Because if that's true, there's no communication with the other ports.
  So we are a Program -- doing something in a loop, and writing to a Port. When the Program ends, the higher context CLOSES the port, and destroys any Inputs. Multiple inputs can be associated into the program -- regardless of how they are associated, at the end of the loop, we will ask them to clean up whatever they need to clean up as a result of being instantiated in the loop. I think inherently, this makes sense -- once a Program terminates, its parent programs should also be told to do cleanup based on the idea that now, they will _never_ emit to this particular node. If that has meaning, the parent -- whatever it is -- should be told to use that meaning, or to discard it and do nothing for cleanup.
  Likewise, the Program closes the Port. This has meaning. In most cases, this means that anyone attempting to 'receive' a value from the Program will be told that the Program is closed. And that's an important thing for them to be told. However, it's unclear as of now what the identity of the Port should be -- a concrete type, or an existential type? We can figure that out later, I suppose. In its raw form, however, we've described the Program  node's essentials. 

However, for an AffList to become a ListInst, this isn't enough. We need to support dynamic creation of runtime Program nodes, and we need to support a _constant_ output -- the ListInst itself. How do we represent that? What does the ListInst need to be capable of? How do we cancel all Program nodes? And if a ListInst gets created in an Aff, how do we ensure that being created in the Aff _automatically_ means that cancellation of the Aff will cancel the ListInst as well?

Well, we need a representation of the Node. And we need its representation as a _data_ structure, because it is included as something the injected program will operate on. The Program Node will have a collection of Parents, where their identities have been erased, so that later we can treat them generically even after we've lost access to the exact types of the parents, and send them specific messages. The Node will contain a Thread, so that when we create the Node, we can develop a program from the totality of the data, and place it in the Thread for running. In other words, all data under creation is created before we develop the final program for it. And for that to be true, we have to define the general structure of the data.
  The Node also needs the concept of a an Output port, somehow, that can be connected to, or given to, other items. A basic Port of two channels ... is probably sufficient for this -- because requesting data from the Port will suspend until the next value is provided. The primary difference is that requesting an item from the Port should ALSO attempt to start the Thread every time -- so that no one else has to do it.
  
If we've defined the Node and the Port so that they can be installed in each other successfully, then we've fully-defined the system that needs to exist for a Node to be run -- a Node simply needs to be configured with a Program that takes advantage of all these features, but in terms of inter-operability with the world, the Node is properly defined.
  But as I said before, the actual ListFiber is not the same as the Program node, and we have to be able to talk about _what_ a Program node is emitting to. Assuming the AffList Monad is created, all the individual Program nodes will be created and linked to each other, and then the _last_ such Program node will be connected to the ListFiber's internal implementation, so that when `LFiber.receive` is called, that makes an appeal to the last Program node's Port. Likewise, when `LFiber.cancel` is called, we will be able to call Cancel on the Program node itself, cancelling the inner program before propagating the Cancel to its inputs. So far, so sensible.
  But this also needs to hold in response to monadic binding, which generates new 
nodes at runtime that emit new values for an existing node. Unlike map or applicative,
this generation occurs once per output item, instead of being a single node that
takes care of the operation of mapping or merging items from multiple streams.
Likewise for something like 'take' or 'groupBy', which transform nodes entirely. Monadic binding in particular is troubling -- the binding implies that we create a node that seeks to _do_ something from the value it receives by requesting from the prior node, the Parent. And what does it do? It uses that new value to create and launch an internal Program Node, and it takes from that Program Node until completion, emitting them into its own output, before destroying it and requesting a new value from the Parent -- each take, of course, is prompted by the request of the Calling context. So monadic binding isn't that difficult, actually. Note as well that each Program's Aff function should have a pre-installed Catch handler for Errors -- when there is an error, the Error is sent into the Port, to flow (eventually) to the ListFiber, where a 'receive' will error. This enables errors to flow upward from bindings, to the eventual output -- and it's s imply a property of Port connections more generally, and the Threads -- installing an Aff function necessarily creates this catch handler.
  Does this, then, give us enough to say what an AffList actually is? Yes, I think so. An AffList is fundamentally just a way to create a Program Node -- an `Effect PNode`. That's ... all it needs to be. The PNode and its parents represents the _entirety_ of the knowledge that is needed to run the list. Sure, some type parts are lost. But in operation that was specified during construction, everything needed is there, and enough. We can also even get MonadThrow and MonadError through a PNode that actually chooses to handle an error that it takes from its Parent node.
  Afterward, in most cases we can us the 'Yield' monad to simplify writing individual monads.
  
This is all very interesting, because it represents the production of a stream of values via pull request from a Calling context. But it's surprisingly very different when it comes to a Flow or Signal, where a Source is pushing values through the pipeline. What differences does this cause?
  It _could_ be bad, because in past cases, it caused us to take Nodes and set Event Handlers all over the case, which is a hard model to understand. But we can do better -- for a Flow or for a Signal, with the right architecture we can still _pretend_ that we are suspending. For a Flow, the Node has Parents and Children, a Start program, a Value program, and a Close program. This is all state; the Start program will only start once as well. The Flow monad will produce the final Node, and calling 'start' on it -- whenever that's done; however that's done -- will start the last item; and when each node passes a value to the next one, it should always ensure a start before passing the value. Thus, many properties are part of node composition -- in this case, ensuring start is part of those properties.
  But with the _right architecture_, adapting a Program to use the architecture well becomes easy to construct, even if we don't have Aff to enable true delays and true resumption. Instead, we can write a program as a simple Start function on the architecture -- the options in the monad are to Load the Next program, to load a Close program, to actually close, and to yield. Thus, the program is responsible for its own recursion and suspension, and has the tools to enable this -- the environment is reified, so even as the start program creates items, it is free to modify its environment's ability to respond to larger events, _based_ on the new, created items. This finds a similar mirror in the Program Node of the AffList -- it can yield, but it can also specify cancellation functions, and inputs are always cleaned up when the Program ends -- but where the Aff can end by simply terminating, the Flow's node ends by _not_ setting a new Next function. 
  But the point is this -- because the architecture is correct, multiple DSLs can be used to express what we want to express. We aren't locked into any one DSL.
  
### Notes on modules and conceptual organization as we program

Each module should provide a set of properties for testing, even if they were wrapped, because they really are separate concepts.

Pure Total State with all refs should be specialized to Some State with only some refs, so focus on specific operations can be done. Implementing the effects is thus a recursive practice of specializing on state; hiding which state is actually being changed at the right conceptual levels. Testing then involves a process of _specializing_ each production data/effect to a _specific_ test data type, and the specific test functions that this enables. This needs to be assisted by the unspecialized form's properties and getters and setters.

TODO -- should 'launchList' have a different implementation in Yield than in Aff? Probably, right?

TODO -- Need other implementations -- take, drop, foldl, scanl, filter, reject, fromFoldable, group -- that only work within AffList

TODO -- no need for 'parents' more generally? Maybe? But no fibers are explicitly forked, so ... maybe this won't work, actually. How do we get the general idea of supervision to work here? Or do we always need an explicit 'finally' to get things to work? Or can we implicitly 'fork' things? But there's no supervision context overall ... unless we consider that supervision context to be the entire AFF computation itself that we are already running -- something that does NOT return, but only cancels on completion of the Aff ... which hopefully works. `launchList` vs `createList` And yet even launchList isn't clean ... because lifting an Aff does NOT necessarily schedule it to be destroyed properly. It certainly seems like asking for 'finally' supervision is the safest way. Or using a 'withList' -- more likely to guarantee cleanup. But it's hard to 'yield' within the nested Aff, since now it's the wrong monad.